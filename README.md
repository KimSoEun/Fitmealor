# Fitmealor
goorm Final Project

핏밀러 (Fitmealor) 프로젝트 기획서
파이널 프로젝트 / 실전형 AI 서비스 개발

1단계. 사용자 시나리오 정의 (User Scenario Design)
1.1 페르소나 정의
- 외국인 유학생 또는 외국인 직장인 - 한국어 이해도는 낮음, 건강을 중시하며 알레르기 또는 식이제한 있음 - 개인 맞춤 식단과 재료 성분 정보 접근이 어려움 

1.2 사용자의 문제
- 식품 라벨이 한국어로만 표기되어 있어 알레르기 성분 파악이 어려움 - 식이 선호(채식, 글루텐 프리 등)에 맞는 메뉴 탐색 어려움 - 음식 추천 서비스가 내 건강상태나 체질을 반영하지 않음 

1.3 서비스 흐름 (입력 → 처리 → 출력)
마이 페이지 - 사용자 정보 입력 (알레르기, 금기식품, 체중목표, 신체정보 등)
메인 화면 - AI 추천 모델이 적합한 식단 추천
상세 화면 - 결과 확인 및 식품 상세 정보 보기 → 주문 연동 (가상)
메인 화면 - 음식, 시제품, 식재료 등의 정보 검색 → 추천/비추천 표시
메인 화면 - 등록 되어있지 않은 시제품의 성분표를 촬영하여 정보 등록 가능
식단 관리 - 매일의 식단을 등록할 수 있음 

1.4 예시 시나리오
- 사용자 A는 한국어가 익숙하지 않은 프랑스 유학생이다. - A는 글루텐 알레르기가 있으며 체중 감량을 목표로 한다.
- 앱에 여러 추천 식단들이 보인다. 하지만 오늘 아ㅊ점심은 저탄고단 식단이 필요하다. - 앱에 "매운 거 빼고, 고단백 저탄수 식단 추천해줘"라고 입력한다. - 시스템은 닭가슴살, 곤약면 등을 기반으로 한 n가지 식사를 추천하고, 음식마다 성분표와 알레르기 유무를 설명한다. 권장 식사량과 칼로리 정보 등도 보여준다.
식단을 정한 후 배달 주문/요리/오프라인 구매 등을 하여 식사를 한다.
해당 식단을 오늘의 점심으로 등록한다.
오늘 저녁부터 권장되는 칼로리와 영양 정보 등이 정리되어 보여진다. 

2단계. UI 워크플로우 구성 (UI Workflow Sketch)
2.1 UI 단계 설계
1. 시작 화면: 로그인/회원가입, 언어 선택 2. 사용자 정보 입력 화면: 건강 상태, 알레르기, 신체 정보 등 3. 메인 입력 화면: 음식 요청 자연어 입력창 + 사진 업로드 4. 결과 화면: 음식 카드 리스트 (사진 + 설명 + 성분) 5. 상세 설명: 클릭 시 확장 → 알레르기 경고, 주문 버튼, 찜 버튼
6. 찜 목록: 식사 후 식사 완료 버튼 클릭
7. 화면 상단: 오늘의 남은 권장 섭취 영양 정보 변경 
2.2 각 화면 기능 정의
1) 시작 화면 (로그인/회원가입, 언어 선택)
입력 요소: 이메일/비밀번호, 소셜 로그인(옵션), 언어 드롭다운(en/ko/…), 약관 동의 체크박스
출력 요소: 브랜드 로고, 서비스 소개 요약, 로그인/회원가입 카드
상호작용:
언어 변경 시 UI 즉시 i18n 반영
“게스트로 시작” → 기능 제한(찜/영양 집계 불가) 안내
예외·상태: 잘못된 자격 증명/중복 가입/네트워크 오류 토스트 표시
백엔드 연동(예시): POST /auth/login, POST /auth/signup, GET /i18n?locale=en

2) 사용자 정보 입력 화면 (건강 상태, 알레르기, 신체 정보 등)
입력 요소: 키/몸무게/나이/성별, 활동수준, 목표(감량/유지/증량), 알레르기(멀티 선택 + 자동완성), 식이제한(비건/할랄/무글루텐 등), 금기 성분
출력 요소: 입력 미리보기(오늘 권장 섭취치 추정), 단위 선택(kg/lb, cm/in)
상호작용:
필수값 미입력 시 다음 단계 비활성화
알레르기 추가·삭제, 태그 형태 편집
“나중에 수정” 가능 (기본 권장치로 계산)
예외·상태: 비현실적 수치(예: 키 20cm) 입력 시 유효성 경고
백엔드 연동: PUT /users/me/profile, GET /nutrition/goals (auto-calc)

3) 메인 입력 화면 (자연어 요청 + 사진 업로드)
입력 요소: 자연어 텍스트(프롬프트 영역), 사진 업로드(라벨/메뉴 사진), 옵션 토글(맵기 제외/해산물 위주/예산 범위 등)
출력 요소: 입력 힌트(예시 프롬프트), 업로드 썸네일, OCR 진행 상태
상호작용:
“추천 받기” 클릭 → (이미지 있으면) OCR → (텍스트/옵션 포함) 추천 생성
음성 입력/번역(선택)
입력 초기화, 재시도
예외·상태: 이미지 포맷/용량 제한, OCR 실패 시 재시도 제안, 네트워크 타임아웃 처리
백엔드 연동:
POST /ocr/extract (파일 업로드 → 성분 텍스트)
POST /recommendations (query, user_profile, ocr_text, filters)

4) 결과 화면 (음식 카드 리스트: 사진 + 설명 + 성분)
출력 요소(카드 단위): 이미지, 음식명, 간단 설명, 핵심 영양(열량/단백질 등), 알레르기 경고 배지, 위험·주의 문구, 추천 이유
상호작용:
정렬/필터(영양/가격/맵기/알레르기 제외), 페이지네이션 또는 무한스크롤
카드 내 “상세 보기”, “찜”, “다른 추천 보기”
예외·상태: 결과 없음(필터 완화 제안), 로딩 스켈레톤, 서버 오류 토스트
백엔드 연동: GET /recommendations?queryId=..., POST /favorites/{itemId}, POST /recommendations/refresh

5) 상세 설명 (확장/모달/전용 화면)
출력 요소:
성분 전체표, 알레르기 위험도, 대체 재료/대안 메뉴, 1회 제공량 조절 슬라이더(영양 자동 재계산), 출처/참조(메뉴 DB/라벨 OCR)
상호작용:
주문 버튼(가상 주문 플로우 진입)
찜 토글(즐겨찾기 추가/해제)
“식단에 추가” (오늘/미래 식단 계획에 담기)
예외·상태: 재고/주문 불가(가상) 상태, 알레르기 고위험 시 재확인 다이얼로그
백엔드 연동: GET /items/{id}, POST /favorites, POST /orders/mock, POST /mealplan/add

6) 찜 목록 (즐겨찾기) + 식사 완료
출력 요소: 찜한 항목 리스트(썸네일, 이름, 1회 제공량 기준 영양), 그룹(아침/점심/저녁/간식) 보기, 정렬/검색
상호작용:
항목별 식사 완료 버튼 → “오늘 섭취”로 기록 & 상단 영양 잔여치 실시간 차감
수량/제공량 변경 후 완료 가능
일괄 제거/선택 제거, 상세 보기 이동, 주문 버튼
예외·상태: 찜 비어있음(추천 이동 CTA), 네트워크 오류 재시도
백엔드 연동:
GET /favorites
POST /intake/complete (itemId, serving, timestamp)
DELETE /favorites/{id}

7) 상단 고정 바 (오늘의 남은 권장 섭취 영양 정보)
출력 요소: 남은 칼로리/단백질/탄수/지방 요약(바/링 UI), 목표 대비 % 표시, 초과 시 경고 색/아이콘
상호작용:
바 클릭 → 영양 상세 패널(미시 영양소, 오늘 섭취 로그, 목표 편집)
날짜 변경(어제/오늘/내일), 목표 편집(개인화 재계산)
실시간 갱신:
“식사 완료” 이벤트 수신 시 즉시 반영(프론트 상태관리 + 폴링/서버 이벤트 선택)
예외·상태: 목표 미설정 시 초기 설정 유도, 게스트 모드 안내(저장 안 됨)
백엔드 연동: GET /nutrition/today, GET /nutrition/goals, PUT /nutrition/goals, GET /intake/logs?date=...

공통 정책(요약)
국제화(i18n): 모든 텍스트 키 기반, 언어 전환 즉시 반영
접근성(a11y): 키보드 포커스, 대체 텍스트, 대비 준수
로깅/분석: user_log에 query, clicked_id, favorited_id, completed_intake, errors 기록
에러/로딩 패턴: 스켈레톤, 토스트, 재시도 버튼 표준화
보안/권한: 찜·완료·목표 수정은 인증 필요, 게스트 제한 고지
 
3단계. 데이터 및 모델 설계
3.1 데이터 항목 정의
- 음식명, 재료, 알레르기 성분, 맵기, 영양성분, 이미지 URL - 사용자 입력: 알레르기 정보, 식이 선호, 목표 등 
3.2 데이터 전처리 계획
- 공공 데이터셋 및 민간 식단 데이터 수집 (JSON/CSV) - 불용어 제거, 토크나이징, 한글 정규화, 영양 성분 추출 
3.3 모델 선택 및 이유
- Clova OCR + Donut 모델 (성분 인식) - Transformers 기반 추천모델 (예: BERT 기반 classifier + ranking) - Hugging Face pretrained 모델 활용 → 파인튜닝 
3.4 기술 흐름도 요약
사용자 입력 (텍스트/이미지) → OCR (성분 추출) + 추천모델 → 필터링 (알레르기, 건강 조건) → 결과 출력 
3.5단계. 데이터베이스 설계
3.5.1 벡터 DB 구조
- 음식 설명 임베딩 → ChromaDB - 메타데이터로 spicy_level, dietary_tags, language 등 포함




 각 Collection 구조 상세 설계
🥫 food_labels (OCR 결과 기반 성분 검색)
Document: OCR로 추출된 전체 텍스트
Embedding: 문장-level 또는 키워드 조합 벡터
Metadata: {
  "image_id": "img_0423",
  "product_name": "두유",
  "detected_allergens": ["대두", "우유"],
  "language": "ko",
  "ocr_model": "clova_ocr"
}


⚠️ ingredient_knowledge (식품 성분 → 알러지 연결 사전)
Document: "카제인은 우유에서 유래한 단백질로, 유당불내증 환자에게 영향을 줄 수 있습니다."
Embedding: 성분 + 설명 임베딩
Metadata:
{
  "ingredient": "카제인",
  "related_allergen": "우유",
  "risk_level": "high",
  "aliases": ["casein", "카세인"]
}


🧪 nutrition_info (영양 카드 벡터 검색용)
Document: "이 제품은 1회 제공량당 250kcal이며 단백질 10g을 포함합니다."
Embedding: 영양 설명 전체
Metadata: 
{
  "product_name": "닭가슴살 스테이크",
  "calories": 250,
  "protein": 10,
  "carbs": 5,
  "fat": 8
}


🙋 user_profiles (사용자 조건 기반 필터링)
Document: "저는 당뇨가 있고, 우유 알레르기가 있습니다."
Embedding: 사용자 건강 상태 설명
Metadata:
{
  "user_id": "user_01",
  "has_diabetes": true,
  "has_allergy": ["우유"],
  "goal": "체중 감량"
}


🍱 meal_recommendation (자연어 질문 → 벡터 검색용 추천식단)
Document: "당뇨 환자를 위한 저탄수화물 식단으로 닭가슴살과 브로콜리를 추천합니다."
Embedding: 식단 설명 전체 벡터
Metadata: {
  "diet_type": "low_carb",
  "target_condition": ["diabetes"],
  "calories": 400,
  "language": "ko"
}

 ✅ 요약

 
3.5.2 일반 DB 구조
- MySQL: 음식명, 설명, 카테고리, 이미지 URL, 성분, 위험요소 - MongoDB: 사용자 로그 저장 (query, click, feedback) 
3.5.3 ID 및 버전 관리 설계
- 모든 음식에 고유 ID 부여 → 벡터 DB와 일반 DB 간 일치 - 벡터 업데이트 시 버전 태그로 관리 (예: v1, v2) 
